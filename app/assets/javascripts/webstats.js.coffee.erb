# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://coffeescript.org/

all_json = {}
chartPie = {}
chartLine = {}
#hooverText = {}
startDate = moment().subtract(7, 'days').toISOString()
endDate = moment().toISOString()

ready = ->
	client = new Keen(
		projectId: '<%= Rails.application.secrets.keen_projectid %>',
		readKey: '<%= Rails.application.secrets.keen_readkey %>',
		protocol: 'https',
		host: 'api.keen.io/3.0',
		requestType: 'jsonp')

	d3.select(window).on('resize', refresh_graphs)

	if $('body.webstats.art').length
		query_and_draw client

	$('#daterange span').html(moment().subtract(7, 'days').format('D/MM/YYYY') + ' - ' + moment().format('D/MM/YYYY'));
	$('#daterange').daterangepicker {
			format: 'DD/MM/YYYY',
			startDate: moment().subtract(7, 'days'),
			endDate: moment(),
			minDate: '01/07/2014',
			maxDate: '31/12/2016',
			dateLimit: { years: 5 },
			showDropdowns: true,
			showWeekNumbers: false,
			timePicker: false,
			timePickerIncrement: 1,
			timePicker12Hour: true,
			ranges: {
				'Today': [moment(), moment()],
				'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],
				'Last 7 Days': [moment().subtract(6, 'days'), moment()],
				'Last 30 Days': [moment().subtract(29, 'days'), moment()],
				'This Month': [moment().startOf('month'), moment().endOf('month')],
				'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')]
			},
			opens: 'left',
			drops: 'down',
			buttonClasses: ['btn', 'btn-sm'],
			applyClass: 'btn-primary',
			cancelClass: 'btn-default',
			separator: ' to ',
			locale: {
				applyLabel: 'Submit',
				cancelLabel: 'Cancel',
				fromLabel: 'From',
				toLabel: 'To',
				customRangeLabel: 'Custom',
				daysOfWeek: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
				monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
				firstDay: 1
			}
		},
		(start, end, label) ->
			return

	$('#daterange').on 'apply.daterangepicker', (ev, picker) ->
		$('#daterange span').html(picker.startDate.format('D/MM/YYYY') + ' - ' + picker.endDate.format('D/MM/YYYY'));

		startDate = picker.startDate.toISOString()
		endDate = picker.endDate.toISOString()

		query_and_draw client
		return

	$('#version').change ->
		query_and_draw client

	$('.data-version').click ->
		$(this).toggleClass 'btn-default'
		$(this).toggleClass 'btn-success'

		if $(this).prop 'dataFilter'
			$(this).prop 'dataFilter', false
		else
			$(this).prop 'dataFilter', true

		query_and_draw client
		return

#	$('.group-button').click ->
#		if $(this).prop 'data-grouped'
#			$(this).addClass 'btn-default'
#			$(this).removeClass 'btn-success'
#			$(this).prop 'data-grouped', false
#		else
#			$('.group-button').addClass 'btn-default'
#			$('.group-button').removeClass 'btn-success'
#			$('.group-button').prop 'data-grouped', false
#			$(this).addClass 'btn-success'
#			$(this).prop 'data-grouped', true
#		return

	$('#group_chart01').click ->
		run_query_art_count client, '#chart01'

	$('#groupP_chart02').click ->
		if $(this).prop 'data-grouped'
			$(this).addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
		else
			$('#groupV_chart02').addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
			$(this).addClass('btn-success').removeClass('btn-default').attr('data-grouped', 'picName')
		run_query_art_daily_count client, '#chart02'
		return

	$('#groupV_chart02').click ->
		if $(this).prop 'data-grouped'
			$(this).addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
		else
			$('#groupP_chart02').addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
			$(this).addClass('btn-success').removeClass('btn-default').attr('data-grouped', 'version')
		run_query_art_daily_count client, '#chart02'
		return

	$('#groupP_chart03').click ->
		if $(this).prop 'data-grouped'
			$('#groupV_chart03').removeClass('btn-default').addClass('btn-success').attr('data-grouped')
			$(this).addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
		else
			$('#groupV_chart03').addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
			$(this).addClass('btn-success').removeClass('btn-default').attr('data-grouped', 'picName')
		run_query_art_group_count client, '#chart03'
		return

	$('#groupV_chart03').click ->
		if $(this).prop 'data-grouped'
			$('#groupP_chart03').removeClass('btn-default').addClass('btn-success').attr('data-grouped')
			$(this).addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
		else
			$('#groupP_chart03').addClass('btn-default').removeClass('btn-success').removeAttr('data-grouped')
			$(this).addClass('btn-success').removeClass('btn-default').attr('data-grouped', 'version')
		run_query_art_group_count client, '#chart03'
		return
		
	return

$(document).ready ready
$(document).on 'page:load', ready

query_and_draw = (client) ->
	run_query_art_count client, '#chart01'
	run_query_art_group_count client, '#chart03'
	run_query_art_daily_count client, '#chart02'

refresh_graphs = ->
	if all_json['#chart01']
		drawBar '#chart01', true
	if all_json['#chart02']
		draw1LineGraph '#chart02', true
	return

init_or_switch_data = (element) ->
	if all_json[element] == undefined
		all_json[element] = {data: {}}
	else
		i = 0
		while i < Object.keys(all_json[element]['data']).length
			name = Object.keys(all_json[element]['data'])[i]
			all_json[element]['data'][name] =
				{old: all_json[element]['data'][name]['new']
				new: null}
			i++

	#console.log all_json[element]
	return

fill_in_new_data_simple = (res, element) ->
	if all_json[element]['data']['Total'] == undefined
		all_json[element]['data']['Total'] = {}
		all_json[element]['data']['Total']['old'] = 0
	all_json[element]['data']['Total']['new'] = res.result

	#console.log all_json[element]
	return

fill_in_new_data_grouped = (res, element, name_getter, value_getter) ->
	i = 0
	while i < res.result.length
		name = (name_getter res.result[i]) #.replace /[^A-Za-z0-9]/g, ''
		if all_json[element]['data'][name] == undefined
			all_json[element]['data'][name] = {}
			all_json[element]['data'][name]['old'] = 0
		all_json[element]['data'][name]['new'] = value_getter res.result[i]
		i++

	#console.log all_json[element]
	return

remove_empty_data = (element) ->
	i = 0
	while i < Object.keys(all_json[element]['data']).length
		name = Object.keys(all_json[element]['data'])[i]
		if all_json[element]['data'][name]['old'] == 0 && all_json[element]['data'][name]['new'] == undefined
			all_json[element]['data'].splice i, 1
		else
			i++

	#console.log all_json[element]
	return

get_pic_name = (value) ->
	return value['picName']

get_pic_value = (value) ->
	return value['result']

build_query = ->
	the_query = {}

	the_versions = []
	$('.data-version').each( ->
		if $(this).prop 'dataFilter'
			the_versions.push $(this).val()
	)

	if the_versions.length > 0
		the_query['filters'] = [
			{property_name: 'version'
			operator: 'in'
			property_value: the_versions}]

	the_query['timeframe'] =
		{start: startDate
		end: endDate}

	return the_query

run_query_art_count = (client, element) ->
	k_query = build_query()
	k_query['eventCollection'] = 'artSeen'
	if $('#group_chart01').prop 'data-grouped'
		k_query['groupBy'] = 'picName'

	query_art_count = new (Keen.Query)('count', k_query)

	#clocky thingy
	$(element).append '<div class="loady"><div class="arc1"></div></div>'

	client.run query_art_count, (err, res) ->
		if err
		else
			init_or_switch_data element

			if $('#group_chart01').prop 'data-grouped'
				fill_in_new_data_grouped res, element, get_pic_name, get_pic_value
			else
				fill_in_new_data_simple res, element

			remove_empty_data element

			drawBar element, false
		return

	return

run_query_art_group_count = (client, element) ->
	k_query = build_query()
	k_query['eventCollection'] = 'artSeen'
	group = ''
	if $('#groupP_chart03').attr 'data-grouped'
		k_query['groupBy'] = 'picName'
		group = 'picName'
	if $('#groupV_chart03').attr 'data-grouped'
		k_query['groupBy'] = 'version'
		group = 'version'

	query_art_count = new (Keen.Query)('count', k_query)

	#clocky thingy
	$(element).append '<div class="loady"><div class="arc1"></div></div>'

	client.run query_art_count, (err, res) ->
		if err
		else
			dataset = []

			j=0
			while j < res['result'].length
				dataset.push []
				dataset[j].push res['result'][j][group]
				dataset[j].push res['result'][j].result
				j++

			drawPieGraph element, dataset
		return

	return

run_query_art_daily_count = (client, element) ->
	k_query = build_query()
	k_query['eventCollection'] = 'artSeen'
	group = ''
	if $('#groupP_chart02').attr 'data-grouped'
		k_query['groupBy'] = 'picName'
		group = 'picName'
	if $('#groupV_chart02').attr 'data-grouped'
		k_query['groupBy'] = 'version'
		group = 'version'
	k_query['interval'] = 'daily'

	query_art_count = new (Keen.Query)('count', k_query)

	#clocky thingy
	$(element).append '<div class="loady"><div class="arc1"></div></div>'

	client.run query_art_count, (err, res) ->
		if err
		else
			all_json[element] = {
				data: {
					xDataset: ['x']
					yDataset: []
				}
			}

			#console.log res

			i=0
			while i < res['result'].length
				xdate = moment(res['result'][i]['timeframe']['start'])
				if moment().isAfter(xdate)
					all_json[element].data.xDataset.push xdate.format('YYYY-MM-DD')
					if group != ''
						j=0
						#console.log res['result'][i].value
						while j < res['result'][i].value.length
							if i==0
								all_json[element].data.yDataset.push []
								all_json[element].data.yDataset[j].push res['result'][i].value[j][group]
							all_json[element].data.yDataset[j].push res['result'][i].value[j].result
							j++
					else
						if i==0
							all_json[element].data.yDataset.push ['Pictures Seen']
						all_json[element].data.yDataset[0].push res['result'][i].value
				i++

			#console.log all_json[element].data

			draw1LineGraph element, false
		return

	return

drawBar = (element, resize) ->
	$(element).html('');
	dataset = $.map all_json[element]['data'], (value, index) ->
		thing = value
		thing['name'] = index
		return [thing];
#	console.log dataset

	axis_XOffset = 50
	axis_YOffset = 6
	text_YOffset = 30
	text_H = 25
	graph_H = $(element).height() - (axis_YOffset + text_H + text_YOffset)
	graph_W = $(element).width() - (axis_XOffset)
	graph_Offset = graph_W * 10 / 100

	dataset.sort (a, b) ->
		if (a.name > b.name)
			return 1;
		if (a.name < b.name)
			return -1;
		return 0

	i = 0
	total = 0
	old_max = 0
	new_max = 0
	old_length = 0
	new_length = 0
	while i < dataset.length
		total += dataset[i].new
		if dataset[i].new > new_max
			new_max = dataset[i].new
		if dataset[i].old > old_max
			old_max = dataset[i].old
		if dataset[i].old > 0
			old_length++
		if dataset[i].new > 0
			new_length++
		i++

	if new_length <= 1
		allbars_W = graph_W
	else
		allbars_W = (graph_W - graph_Offset)

	if old_length == 0
		old_length = new_length
		
	if svgChart
		svgChart.remove()

	svgChart = d3.select(element)
	.append 'svg'
	.attr 'width', $(element).width()
	.attr 'height', $(element).height()

	#XSCALE
	scaleX = []
	scaleXNames = []

	if new_length == 0
		scaleX.push 0
		scaleX.push graph_W
		scaleXNames.push 'No Results'
		axis_width = graph_W
	else
		if new_length == 1
			the_v = 0
		else
			the_v = graph_Offset / (new_length - 1)

		c = 0
		i = 0
		pending = false
		while c < dataset.length
			if pending
				scaleX.push ((allbars_W/new_length) * i)
				scaleXNames.push 'xxx'+i
				pending = false
			if dataset[c].new != null
				scaleX.push (( (allbars_W/new_length) + the_v) * i)
				scaleXNames.push '(' + dataset[c].new + ') ' + dataset[c].name
				pending = true
				i++
			c++

		scaleX.push graph_W
		axis_width = allbars_W/new_length

#	console.log scaleX
#	console.log scaleXNames

	scaleXCount = d3.scale.ordinal()
	.range scaleX
	.domain scaleXNames

	xAxis = d3.svg.axis()
	.scale scaleXCount
	.orient "bottom"

	svgChart.append("g")
	.attr "class", "xaxis"
	.attr "transform", "translate("+axis_XOffset+"," + (axis_YOffset+graph_H+1) + ")"
	.call xAxis
	.selectAll ".tick text"
	.call wrap, axis_width

	#Y SCALE
	scaleYCount = d3.scale.linear()
	.domain [0, new_max]
	.range [graph_H, 0]

	yAxisTicks = d3.svg.axis()
	.scale scaleYCount
	.orient "left"
	.ticks 5

	svgChart.append("g")
	.attr "class", "yaxis"
	.attr "transform", "translate("+(axis_XOffset-1)+","+axis_YOffset+")"
	.call yAxisTicks

	rect = svgChart.selectAll 'rect'
	.data dataset
	.enter()
	.append 'rect'

	hoover_ready = resize
	rect.on 'mouseover', (d, i) ->
		if hoover_ready
#			hooverText = svgChart.append 'text'
#			.text d.name + ' = ' + d.new
#			.attr 'text-anchor', 'middle'
#			.attr 'x', $(element).width()/2
#			.attr 'y', (axis_YOffset + graph_H + text_YOffset + text_H)
#			.attr 'font-family', 'sans-serif'
#			.attr 'font-size', text_H + 'px'

			d3.select this
			.transition()
			.duration 250
			.attr 'fill', ->
				if new_length <= 0
					v = 'rgb(165, 42, 42)'
				else
					j = 0
					c = 0
					while c < i
						if dataset[c].new > 0
							j++
						c++
					v = d3.rgb(165,42,42).darker(3*((new_length-j)/new_length))
				return v
		return
	.on 'mouseout', (d, i) ->
		if hoover_ready
			d3.select this
			.transition()
			.duration 350
			.attr 'fill', ->
				if new_length <= 0
					v = 'rgb(70,130,180)'
				else
					j = 0
					c = 0
					while c < i
						if dataset[c].new > 0
							j++
						c++
					v = d3.rgb(70,130,180).darker(3*(j/new_length))
				return v
#			hooverText.remove()
		return

	if !resize
		rect_animated = rect.transition()
		.duration 1000
		.each 'start', (d, i) ->
			hoover_ready = false
			d3.select this
			.attr 'x', ->
				if old_length <= 1
					v = 0
				else
					j = 0
					c = 0
					while c < i
						if dataset[c].old > 0
							j++
						c++

					v = (allbars_W/old_length + graph_Offset / (old_length - 1))*j

				return v + axis_XOffset
			.attr 'y', ->
				if old_max == 0
					old_h_ratio = 0
				else
					old_h_ratio = d.old / old_max
				return graph_H - (old_h_ratio * graph_H) + axis_YOffset
			.attr 'width', ->
				if old_length <= 0
					v = 0
				else
					v = allbars_W/old_length
				return v
			.attr 'height', ->
				if old_max == 0
					old_h_ratio = 0
				else
					old_h_ratio = d.old / old_max
				return old_h_ratio * graph_H
			.attr 'fill', ->
				if old_length <= 1
					v = 'rgb(70,130,180)'
				else
					j = 0
					c = 0
					while c < i
						if dataset[c].old > 0
							j++
						c++
					v = d3.rgb(70,130,180).darker(3*(j/old_length))
				return v
			return
		.each "end", ->
			hoover_ready = true
			return
	else
		rect_animated = rect

	rect_animated.attr 'x', (d, i) ->
		if new_length <= 1
			v = 0
		else
			j = 0
			c = 0
			while c < i
				if dataset[c].new > 0
					j++
				c++
			v = (allbars_W/new_length + graph_Offset / (new_length - 1))*j
		return v + axis_XOffset
	.attr 'y', (d) ->
		if new_max == 0
			new_h_ratio = 0
		else
			new_h_ratio = d.new / new_max
		return graph_H - (new_h_ratio * graph_H) + axis_YOffset
	.attr 'width', (d) ->
		if new_length <= 0
			v = 0
		else
			v = allbars_W/new_length
		return v
	.attr 'height', (d) ->
		if new_max == 0
			new_h_ratio = 0
		else
			new_h_ratio = d.new / new_max
		return new_h_ratio * graph_H
	.attr 'fill', (d, i) ->
		if new_length <= 1
			v = 'rgb(70,130,180)'
		else
			j = 0
			c = 0
			while c < i
				if dataset[c].new > 0
					j++
				c++
			v = d3.rgb(70,130,180).darker(3*(j/new_length))
		return v
	return

draw1LineGraph = (element, resize) ->
	$(element).html('');

#	if chartLine
#		chartLine.remove()

	chartColumns = []
	chartColumns.push all_json[element]['data']['xDataset']
	chartTypes = {}
	i = 0
	while i < all_json[element]['data']['yDataset'].length
		chartColumns.push all_json[element]['data']['yDataset'][i]
		chartTypes[all_json[element]['data']['yDataset'][i][0]] = 'area' #'area-spline'
		i++

	chartLine = c3.generate({
		axis: {
			x: {
				type: 'timeseries'
				tick: {
					format: '%d-%m-%Y'
				}
			}
		}
		bindto: element
		data: {
			x: 'x'
			columns: chartColumns
			types: chartTypes
		}
		size: {
			height: $(element).height()
			width: $(element).width()
		}
	})

	return

drawPieGraph = (element, dataset) ->
	$(element + ' > div.loady').remove()

	chartColumns = []
	i = 0
	while i < dataset.length
		chartColumns.push dataset[i]
		i++

	if chartPie[element]
		unload_array = $.map chartPie[element].data(), (value, index) ->
			return value.id
		chartPie[element].load({
			columns: chartColumns
			unload: unload_array
		})
	else
		chartPie[element] = c3.generate({
			bindto: element
			data: {
				columns: chartColumns
				type: 'pie'
			}
			legend: {
				position: 'right'
			}
			size: {
				height: $(element).height()
				width: $(element).width()
			}
			tooltip:
				format:
					title: (d) ->
						return d
					value: (value, ratio, id) ->
						return value + ' - ' + Math.floor(ratio*100) + '%'
		})

	return

wrap = (texty, width) ->
	texty.each ->
		text = d3.select(this)
		if text.text().match(/xxx\d+/g) == null
			words = text.text().split(/\s+/).reverse()
			word = undefined
			line = []
			lineNumber = 0
			lineHeight = 1.1
			y = text.attr('y')
			dy = parseFloat(text.attr('dy'))
			tspan = text.text(null).append('tspan').attr('x', width/2).attr('y', y).attr('dy', dy + 'em')
			while word = words.pop()
				line.push word
				tspan.text line.join(' ')
				#				console.log '------------'
				#				console.log tspan.text()
				#				console.log line
				#				console.log words
				if tspan.node().getComputedTextLength() > width
					if line.length == 1
						temp = line.pop()
						words.push temp.substr(0, temp.length-2).concat('.')
					else
						words.push line.pop()
						tspan.text line.join(' ')
						line = []
						tspan = text.append('tspan').attr('x', width/2).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(null)
		else
			text.remove()
		return
	return